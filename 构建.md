

## **高可用 WireGuard + GOST 代理 Docker 项目总结**

### **1. 项目目标**

本项目旨在创建一个功能强大且高度稳定的 Docker 容器，实现以下目标：

  * 通过 `wgcf` 连接到 Cloudflare WARP 网络，以获取网络访问能力。
  * 内置优选IP脚本，自动扫描并使用延迟最低的 WARP 节点。
  * 内置健康检查和自动重连机制，当连接中断时能自动切换IP并恢复服务。
  * 使用功能强大的 `gost` 提供 SOCKS5 和 HTTP 代理服务，并完全支持 UDP 转发。
  * 支持通过环境变量对代理端口、认证信息等进行灵活配置，无需修改代码。
  * 支持跨平台构建，可在 `amd64` 和 `arm64` 等架构上运行。

-----

### **2. 最终文件**

#### **2.1 `Dockerfile.alpine` (最终版)**

这个 Dockerfile 使用 `gost v2.12.0`，并包含了所有修正，以确保构建过程的稳定性。

```dockerfile
# Dockerfile 使用 gost v2.12.0

FROM alpine:3.17

# 定义 gost 版本和平台架构参数
ARG GOST_VERSION=2.12.0
ARG TARGETPLATFORM

# 安装基础依赖
RUN apk update -f \
  && apk --no-cache add -f \
  wget curl ca-certificates \
  iproute2 net-tools iptables \
  wireguard-tools openresolv tar \
  && rm -rf /var/cache/apk/*

# 下载并安装 GOST
RUN set -ex \
    # 根据构建平台自动选择架构名称
    && case "${TARGETPLATFORM}" in \
        "linux/amd64") ARCH="amd64" ;; \
        "linux/arm64") ARCH="arm64" ;; \
        *) echo "不支持的平台: ${TARGETPLATFORM}" ; exit 1 ;; \
    esac \
    # 使用 v2.12.0 的正确链接格式进行下载
    && wget -L -O gost.tar.gz --user-agent="Mozilla/5.0" "https://github.com/ginuerzh/gost/releases/download/v${GOST_VERSION}/gost_${GOST_VERSION}_linux_${ARCH}.tar.gz" \
    # 解压、移动并清理
    && tar -xf gost.tar.gz \
    && mv gost /usr/local/bin/gost \
    && chmod +x /usr/local/bin/gost \
    && rm gost.tar.gz

# 安装 wgcf
RUN curl -fsSL git.io/wgcf.sh | bash && mv wgcf /usr/local/bin/wgcf

# 设置工作目录并挂载卷
WORKDIR /wgcf
VOLUME /wgcf

# 复制并授权启动脚本
COPY entry.sh /entry.sh
RUN chmod +x /entry.sh

# 设置入口点
ENTRYPOINT ["/entry.sh"]
```

#### **2.2 `entry.sh` (最终全功能版)**

这个启动脚本包含了优选IP、健康检查、自动重连、以及同时支持 SOCKS5 和 HTTP 代理的所有逻辑。

```sh
#!/bin/sh
set -e

# ==============================================================================
# 脚本配置
# ==============================================================================
BEST_IP_FILE="/wgcf/best_ips.txt"
OPTIMIZE_INTERVAL=21600
WARP_CONNECT_TIMEOUT=5
BEST_IP_COUNT=20
HEALTH_CHECK_INTERVAL=60

# ==============================================================================
# 工具函数
# ==============================================================================
red() { echo -e "\033[31m\033[01m$1\033[0m"; }
green() { echo -e "\033[32m\033[01m$1\033[0m"; }
yellow() { echo -e "\033[33m\033[01m$1\033[0m"; }

archAffix(){
    case "$(uname -m)" in
        aarch64 | arm64 | armv8 ) echo 'arm64' ;;
        x86_64 | amd64 ) echo 'amd64' ;;
        * ) red "❌ 不支持的CPU架构: $(uname -m)" && exit 1 ;;
    esac
}

# ==============================================================================
# IP优选相关函数
# ==============================================================================
download_warp_tool_if_needed() {
    if [ -f "warp" ]; then chmod +x warp; return; fi
    local arch=$(archAffix)
    local url="https://gitlab.com/Misaka-blog/warp-script/-/raw/main/files/warp-yxip/warp-linux-$arch"
    green "🌐 正在下载 WARP 优选工具 (架构: $arch)..."
    if curl -fsSL "$url" -o warp; then chmod +x warp; green "✅ WARP 优选工具下载完成。"; else red "❌ WARP 优选工具下载失败。" && exit 1; fi
}

run_ip_selection() {
    local ip_version_flag=""; [ "$1" = "-6" ] && ip_version_flag="-ipv6"
    green "🚀 开始优选 WARP Endpoint IP..."; download_warp_tool_if_needed
    ./warp -t "$WARP_CONNECT_TIMEOUT" ${ip_version_flag} > /dev/null
    if [ -f "result.csv" ]; then
        green "✅ 优选完成，正在处理结果..."
        awk -F, '($2+0) < 50 && $3!="timeout ms" {print $1}' result.csv | head -n "$BEST_IP_COUNT" > "$BEST_IP_FILE"
        if [ -s "$BEST_IP_FILE" ]; then green "✅ 已生成包含 $(wc -l < "$BEST_IP_FILE") 个IP的优选列表。"; else red "⚠️ 未能筛选出合适的IP，将使用默认地址。"; echo "engage.cloudflareclient.com:2408" > "$BEST_IP_FILE"; fi
        rm -f result.csv
    else
        red "⚠️ 未生成优选结果，将使用默认地址。"; echo "engage.cloudflareclient.com:2408" > "$BEST_IP_FILE"
    fi
}

# ==============================================================================
# 代理和连接核心功能
# ==============================================================================
_downwgcf() {
    yellow "正在清理 WireGuard 接口..."; wg-quick down wgcf >/dev/null 2>&1 || echo "wgcf 接口不存在或已关闭。"; yellow "清理完成。"; exit 0
}

update_wg_endpoint() {
    if [ ! -s "$BEST_IP_FILE" ]; then red "❌ 优选IP列表为空！将执行一次紧急IP优选..."; run_ip_selection "$1"; fi
    local random_ip=$(shuf -n 1 "$BEST_IP_FILE")
    green "🔄 已从优选列表随机选择新 Endpoint: $random_ip"
    sed -i "s/^Endpoint = .*$/Endpoint = $random_ip/" /etc/wireguard/wgcf.conf
}

_startProxyServices() {
    if ! pgrep -f "gost" > /dev/null; then
        yellow "starting GOST proxy services..."
        
        local GOST_COMMAND="gost"
        
        # --- SOCKS5 代理配置 ---
        local SOCKS5_PORT="${PORT:-1080}"
        local AUTH_INFO=""
        [ -n "$USER" ] && [ -n "$PASSWORD" ] && AUTH_INFO="${USER}:${PASSWORD}@"
        local HOST_IP="${HOST:-0.0.0.0}"
        
        local SOCKS5_LISTEN_ADDR="socks5://${AUTH_INFO}${HOST_IP}:${SOCKS5_PORT}"
        GOST_COMMAND="${GOST_COMMAND} -L ${SOCKS5_LISTEN_ADDR}"
        green "✅ SOCKS5 代理已配置 (端口: ${SOCKS5_PORT})。"
        
        # --- HTTP 代理配置 (可选) ---
        if [ -n "$HTTP_PORT" ]; then
            local HTTP_LISTEN_ADDR="http://${AUTH_INFO}${HOST_IP}:${HTTP_PORT}"
            GOST_COMMAND="${GOST_COMMAND} -L ${HTTP_LISTEN_ADDR}"
            green "✅ HTTP 代理已配置 (端口: ${HTTP_PORT})。"
        fi
        
        # 启动 gost
        eval "${GOST_COMMAND} &"
        
        yellow "✅ GOST 服务已启动。"
    fi
}

_check_connection() {
    local check_url="ipinfo.io/json"; local curl_opts="--max-time 4 --silent"
    if [ "$1" = "-6" ]; then check_url="ipv6.google.com"; curl_opts="-6 --max-time 4 --silent"; fi
    if curl ${curl_opts} ${check_url} > /dev/null; then return 0; else return 1; fi
}

# ==============================================================================
# 主运行函数
# ==============================================================================
runwgcf() {
    trap '_downwgcf' ERR TERM INT
    [ ! -e "wgcf-account.toml" ] && wgcf register --accept-tos
    [ ! -e "wgcf-profile.conf" ] && wgcf generate
    cp wgcf-profile.conf /etc/wireguard/wgcf.conf
    [ "$1" = "-6" ] && sed -i 's/AllowedIPs = 0.0.0.0\/0/#AllowedIPs = 0.0.0.0\/0/' /etc/wireguard/wgcf.conf
    [ "$1" = "-4" ] && sed -i 's/AllowedIPs = ::\/0/#AllowedIPs = ::\/0/' /etc/wireguard/wgcf.conf
    [ ! -f "$BEST_IP_FILE" ] && run_ip_selection "$@"
    ( while true; do sleep "$OPTIMIZE_INTERVAL"; yellow "🔄 [定时任务] 开始更新IP列表..."; wg-quick down wgcf >/dev/null 2>&1 || true; run_ip_selection "$@"; yellow "🔄 [定时任务] IP列表更新完成。"; done ) &
    while true; do
        while true; do
            update_wg_endpoint "$@"; wg-quick up wgcf
            if _check_connection "$@"; then green "✅ WireGuard 连接成功！"; break; else red "❌ 连接失败，正在更换IP重试..."; wg-quick down wgcf >/dev/null 2>&1 || true; sleep 3; fi
        done
        _startProxyServices
        green "进入连接监控模式..."
        while true; do
            sleep "$HEALTH_CHECK_INTERVAL"
            if ! _check_connection "$@"; then red "💔 连接已断开！将返回连接阶段进行自动重连..."; wg-quick down wgcf >/dev/null 2>&1 || true; break; fi
        done
    done
}

# ==============================================================================
# 脚本入口
# ==============================================================================
cd /wgcf
if [ -z "$@" ] || [[ "$1" = -* ]]; then
    runwgcf "$@"
else
    exec "$@"
fi
```

-----

### **3. 完整操作流程**

#### **步骤一：准备文件**

1.  在您的电脑上（例如 Windows）创建一个新的项目文件夹，如 `gost-proxy`。
2.  将上面提供的 `Dockerfile.alpine` 和 `entry.sh` 的内容，分别保存为对应的文件，并放到 `gost-proxy` 文件夹中。

#### **步骤二：构建 Docker 镜像 (以 arm64 为例)**

1.  打开终端 (如 PowerShell)，进入您创建的项目文件夹：
    ```powershell
    cd path\to\gost-proxy
    ```
2.  执行构建命令：
    ```powershell
    docker build -t my-gost-proxy:latest -f Dockerfile.alpine --platform linux/arm64 .
    ```

#### **步骤三：保存并传输镜像**

1.  构建成功后，将镜像打包成 `.tar` 文件：
    ```powershell
    docker save -o gost-proxy-arm64.tar my-gost-proxy:latest
    ```
2.  将生成的 `gost-proxy-arm64.tar` 文件传输到您的 Armbian 服务器上。

#### **步骤四：在 Armbian 服务器上部署**

1.  在 Armbian 服务器上，加载镜像：
    ```bash
    docker load -i gost-proxy-arm64.tar
    ```
2.  创建一个用于持久化存储配置的目录：
    ```bash
    mkdir -p wgcf
    ```

#### **步骤五：启动并持久化运行容器**

执行下面的命令来启动容器。您可以根据需要修改 `-e` 参数。

```bash
docker run -d \
   --name wgcf-gost \
   --restart unless-stopped \
   # --- 可选的配置参数 ---
   -e PORT=1080 \
   -e HTTP_PORT=8080 \
   -e USER=admin \
   -e PASSWORD=password123 \
   # -------------------
   --sysctl net.ipv6.conf.all.disable_ipv6=0 \
   --privileged --cap-add net_admin \
   -v /lib/modules:/lib/modules \
   -v $(pwd)/wgcf:/wgcf \
   # --- 端口映射 ---
   -p 1080:1080 \
   -p 8080:8080 \
   # ----------------
   my-gost-proxy:latest -4
```

-----

### **4. 可配置参数 (环境变量)**

您可以通过在 `docker run` 命令中添加 `-e` 参数来灵活配置服务。

| 环境变量 | 作用 | 示例 | 默认值 |
| :--- | :--- | :--- | :--- |
| `PORT` | SOCKS5 代理的端口号 | `-e PORT=8888` | `1080` |
| `HTTP_PORT`| **HTTP 代理的端口号 (设置此项即开启HTTP代理)** | `-e HTTP_PORT=8889`| (未设置，不开启) |
| `USER` | SOCKS5 和 HTTP 代理的用户名 (可选) | `-e USER=myuser` | (无) |
| `PASSWORD` | SOCKS5 和 HTTP 代理的密码 (可选) | `-e PASSWORD=secret`| (无) |
| `HOST` | 代理监听的IP地址 ( `0.0.0.0` 代表监听所有网络接口) | `-e HOST=127.0.0.1` | `0.0.0.0` |

-----

### **5. 日常管理命令**

  * **查看运行状态**: `docker ps`
  * **查看实时日志**: `docker logs -f wgcf-gost`
  * **停止服务**: `docker stop wgcf-gost`
  * **启动服务**: `docker start wgcf-gost`
  * **删除容器**: `docker rm -f wgcf-gost`

这份文档涵盖了从头到尾的所有细节和最终代码，希望能成为您有用的备份。我们共同完成了一个非常棒的项目！
